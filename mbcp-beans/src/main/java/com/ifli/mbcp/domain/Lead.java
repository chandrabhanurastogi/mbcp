package com.ifli.mbcp.domain;

import java.io.Serializable;
import java.util.Date;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

import com.ifli.mbcp.util.CounterUtil;
import com.ifli.mbcp.util.MBCPConstants;

/**
 * Represents a Lead, which is a prospect, or potential customer for an IFLI
 * insurance product. Depending on whether the lead actually purchases the
 * insurance product, he/she may graduate to become a full-fledged customer. <br/>
 * <br/>
 * Nevertheless, the Lead remains the key entity of this application and will
 * feature in most of the service implementations.
 * 
 * @author FL867
 * @version 1.0
 * @since 29 April 2013
 */
@Entity
@Table(name = "tbl_lead")
public class Lead implements Serializable
{
	private static final long	serialVersionUID	= 2677991942498741732L;

	/**
	 * Unique identifier for a given lead instance.
	 */
	private Long				leadId;

	/**
	 * Personal details about the lead; name, addresses, family details, PAN
	 * card, etc.
	 */
	private CustomerDetails		leadCustomerDetails;

	/**
	 * Open, closed, hot, cold, etc., represents the different statii that a
	 * lead instance can be in.
	 */
	private LeadType			leadType;
	private LeadStatus			leadStatus;
	private BDMCode				bdmCode;
	private LeadCategory		leadCategory;
	private Channel				channelSelection;
	private BranchCode			branchCode;
	private BMRMCode			bmRmCode;
	private LeadGeneratorCode	leadGeneratorCode;
	private Date				appointmentScheduled;
	private String				comments;
	private Date				modifiedDate;
	private Date				createdDate;
	private TaskType			taskType;
	private Set<NeedsAnalysis>	needsAnalysis;
	private Set<Proposal>		proposalsMade;
	private Set<Policy>			purchasedPolicies;
	private KindOfLead			kindOfLead;
	private Short				lifecycleState;

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	public Long getLeadId()
	{
		return leadId;
	}

	public void setLeadId(Long leadId)
	{
		this.leadId = leadId;
	}

	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name = "customerDetailsId", nullable = false)
	public CustomerDetails getLeadCustomerDetails()
	{
		return leadCustomerDetails;
	}

	public void setLeadCustomerDetails(CustomerDetails leadCustomerDetails)
	{
		this.leadCustomerDetails = leadCustomerDetails;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "leadStatusId", nullable = false)
	public LeadStatus getLeadStatus()
	{
		return leadStatus;
	}

	public void setLeadStatus(LeadStatus leadStatus)
	{
		this.leadStatus = leadStatus;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "channelId", nullable = false)
	public Channel getChannelSelection()
	{
		return channelSelection;
	}

	public void setChannelSelection(Channel channelSelection)
	{
		this.channelSelection = channelSelection;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "branchCodeId", nullable = false)
	public BranchCode getBranchCode()
	{
		return branchCode;
	}

	public void setBranchCode(BranchCode branchCode)
	{
		this.branchCode = branchCode;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "bmRmCodeId", nullable = false)
	public BMRMCode getBmRmCode()
	{
		return bmRmCode;
	}

	public void setBmRmCode(BMRMCode bmRmCode)
	{
		this.bmRmCode = bmRmCode;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "leadGeneratorCodeId", nullable = false)
	public LeadGeneratorCode getLeadGeneratorCode()
	{
		return leadGeneratorCode;
	}

	public void setLeadGeneratorCode(LeadGeneratorCode leadGeneratorCode)
	{
		this.leadGeneratorCode = leadGeneratorCode;
	}

	@Column
	public Date getAppointmentScheduled()
	{
		return appointmentScheduled;
	}

	public void setAppointmentScheduled(Date appointmentScheduled)
	{
		this.appointmentScheduled = appointmentScheduled;
	}

	/**
	 * Unidirectional One-to-Many on Needs Analysis. A single Lead can own many
	 * NAs, but we don't need the return relationship. The JoinColumn will place
	 * a leadId in the NeedsAnalysis table when it is generated by hbm2ddl.
	 * 
	 * @return
	 */
	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "leadId")
	public Set<NeedsAnalysis> getNeedsAnalysis()
	{
		return needsAnalysis;
	}

	public void setNeedsAnalysis(Set<NeedsAnalysis> needsAnalysis)
	{
		this.needsAnalysis = needsAnalysis;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "bdmCodeId", nullable = false)
	public BDMCode getBdmCode()
	{
		return bdmCode;
	}

	public void setBdmCode(BDMCode bdmCode)
	{
		this.bdmCode = bdmCode;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "leadCategoryId", nullable = false)
	public LeadCategory getLeadCategory()
	{
		return leadCategory;
	}

	public void setLeadCategory(LeadCategory leadCategory)
	{
		this.leadCategory = leadCategory;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "leadTypeId", nullable = false)
	public LeadType getLeadType()
	{
		return leadType;
	}

	public void setLeadType(LeadType leadType)
	{
		this.leadType = leadType;
	}

	@Column(length = 1024, nullable = true)
	public String getComments()
	{
		return comments;
	}

	public void setComments(String comments)
	{
		this.comments = comments;
	}

	@Temporal(TemporalType.TIMESTAMP)
	public Date getModifiedDate()
	{
		return modifiedDate;
	}

	public void setModifiedDate(Date modifiedDate)
	{
		this.modifiedDate = modifiedDate;
	}

	@Temporal(TemporalType.TIMESTAMP)
	public Date getCreatedDate()
	{
		return createdDate;
	}

	public void setCreatedDate(Date createdDate)
	{
		this.createdDate = createdDate;
	}

	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "leadId")
	public Set<Proposal> getProposalsMade()
	{
		return proposalsMade;
	}

	public void setProposalsMade(Set<Proposal> proposal)
	{
		this.proposalsMade = proposal;
	}

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "taskTypeId", nullable = true)
	public TaskType getTaskType()
	{
		return taskType;
	}

	public void setTaskType(TaskType taskType)
	{
		this.taskType = taskType;
	}

	/**
	 * Implements a padded leadId getter. In the database we save the leadId as
	 * a Long for efficient storage and good performance. However, the business
	 * requirement states that the leadId should be an alphanumeric field. To
	 * get around this, we pad the Long leadId with the text characters by
	 * either suffixing or prefixing the necessary amount of padding. <br>
	 * <br>
	 * The service layer will interact with the padded methods, while the DAO
	 * will work with the actual getter and setter for the leadId. <br>
	 * <br>
	 * Clarified with BA (Gaurav K) on 13-May-2013 at 16:10; see e-mail with
	 * subject: "Fields Format Counter Details"
	 */
	@Transient
	public String getPaddedLeadId()
	{
		String paddedLeadId = "";
		try
		{
			paddedLeadId = (MBCPConstants.REFID_PREFIX + CounterUtil.zeroPad(getLeadId().longValue(), MBCPConstants.FIELD_WIDTH));
		}
		catch (Exception e)
		{

		}
		return paddedLeadId;

	}

	/**
	 * Implements a padded leadId setter. In the database we save the leadId as
	 * a Long for efficient storage and good performance. However, the business
	 * requirement states that the leadId should be an alphanumeric field. To
	 * get around this, we pad the Long leadId with the text characters by
	 * either suffixing or prefixing the necessary amount of padding. <br>
	 * <br>
	 * The service layer will interact with the padded methods, while the DAO
	 * will work with the actual getter and setter for the leadId. <br>
	 * <br>
	 * Clarified with BA (Gaurav K) on 13-May-2013 at 16:10; see e-mail with
	 * subject: "Fields Format Counter Details"
	 */
	public void setPaddedLeadId(String refId)
	{
		try
		{
			// Strip out the padding and save to the actual leadId
			if ((refId != null) && (refId.contains(MBCPConstants.REFID_PREFIX)))
			{

				setLeadId(Long.parseLong(CounterUtil.removeLeadingZeros(refId.substring(refId.lastIndexOf(MBCPConstants.REFID_PREFIX) + 2, refId.length()))));

			}
			else
			{
				setLeadId(Long.parseLong(refId));
			}
		}
		catch (Exception e)
		{

		}
	}

	/**
	 * Unidirectional One-to-Many on Policy. A single Lead can own many
	 * Policies, but we don't need the return relationship. The JoinColumn will
	 * place a leadId in the Policy table when it is generated by hbm2ddl.
	 * 
	 * @return
	 */
	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "leadId")
	public Set<Policy> getPurchasedPolicies()
	{
		return purchasedPolicies;
	}

	public void setPurchasedPolicies(Set<Policy> purchasedPolicies)
	{
		this.purchasedPolicies = purchasedPolicies;
	}

	/**
	 * This represents the kind of lead that this is; for example this could be individual lead,
	 * group lead, etc.
	 * <br><br>
	 * This will be used to determine the kind of padding used in the getPaddedLeadId() method.
	 * @return
	 */
	@OneToOne
	@JoinColumn(name = "kindOfLeadId")
	public KindOfLead getKindOfLead()
	{
		return kindOfLead;
	}

	public void setKindOfLead(KindOfLead kindOfLead)
	{
		this.kindOfLead = kindOfLead;
	}

	public Short getLifecycleState()
	{
		return lifecycleState;
	}

	public void setLifecycleState(Short lifecycleState)
	{
		this.lifecycleState = lifecycleState;
	}
}
